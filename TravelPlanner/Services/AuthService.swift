import Foundation
import Combine

class AuthService {
    private let networkManager = NetworkManager.shared
    @Published var toastMessage: String?
    @Published var showToast: Bool = false
    @Published var toastType: ToastType?
    private var cancellables = Set<AnyCancellable>()
    
    private var isRefreshingToken = false // Bi·∫øn ki·ªÉm so√°t tr·∫°ng th√°i refresh token

        func refreshToken() -> AnyPublisher<RefreshTokenResponse, Error> {
            // Ki·ªÉm tra n·∫øu ƒëang refresh token th√¨ kh√¥ng g·ªçi l·∫°i
            guard !isRefreshingToken else {
                print("üîÑ Refresh token already in progress, skipping")
                return Fail(error: NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "ƒêang l√†m m·ªõi token, b·ªè qua y√™u c·∫ßu."])).eraseToAnyPublisher()
            }

            isRefreshingToken = true // ƒê√°nh d·∫•u ƒëang refresh
            print("üîÑ Starting token refresh")

            // 1. L·∫•y refresh token t·ª´ UserDefaults
            guard let refreshToken = UserDefaults.standard.string(forKey: "refreshToken") else {
                isRefreshingToken = false
                DispatchQueue.main.async {
                    print("üîî Sending showAuthErrorAlert notification for missing refresh token")
                    NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                        "title": "Phi√™n ƒêƒÉng Nh·∫≠p H·∫øt H·∫°n",
                        "message": "Phi√™n ƒëƒÉng nh·∫≠p c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i."
                    ])
                }
                return Fail(error: NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Kh√¥ng t√¨m th·∫•y refresh token."])).eraseToAnyPublisher()
            }
            
            print("üîç Current refreshToken: \(refreshToken)")
            
            // 2. T·∫°o URL cho endpoint
            guard let url = URL(string: "\(APIConfig.baseURL)/auth/handle-refresh-token") else {
                isRefreshingToken = false
                DispatchQueue.main.async {
                    print("üîî Sending showAuthErrorAlert notification for invalid URL")
                    NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                        "title": "L·ªói K·∫øt N·ªëi",
                        "message": "C√≥ l·ªói x·∫£y ra khi k·∫øt n·ªëi v·ªõi m√°y ch·ªß. Vui l√≤ng th·ª≠ l·∫°i sau."
                    ])
                }
                return Fail(error: URLError(.badURL)).eraseToAnyPublisher()
            }
            
            // 3. T·∫°o request
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "POST"
            urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
            
            // 4. T·∫°o body ch·ª©a refresh token
            let body: [String: Any] = ["refreshToken": refreshToken]
            do {
                urlRequest.httpBody = try JSONSerialization.data(withJSONObject: body)
                if let jsonString = String(data: urlRequest.httpBody!, encoding: .utf8) {
                    print("üì§ Request body for refreshToken: \(jsonString)")
                }
            } catch {
                isRefreshingToken = false
                DispatchQueue.main.async {
                    print("üîî Sending showAuthErrorAlert notification for JSON encoding error")
                    NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                        "title": "L·ªói K·∫øt N·ªëi",
                        "message": "C√≥ l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau."
                    ])
                }
                return Fail(error: error).eraseToAnyPublisher()
            }
            
            // 5. G·ª≠i request v√† x·ª≠ l√Ω ph·∫£n h·ªìi
            return networkManager.performRequest(urlRequest, decodeTo: RefreshTokenResponse.self)
                .handleEvents(receiveCompletion: { [weak self] _ in
                    self?.isRefreshingToken = false // Reset tr·∫°ng th√°i sau khi ho√†n th√†nh
                    print("üîÑ Finished token refresh")
                })
                .catch { [weak self] error -> AnyPublisher<RefreshTokenResponse, Error> in
                    self?.isRefreshingToken = false
                    if let urlError = error as? URLError,
                       urlError.code == .cannotDecodeContentData,
                       let statusCode = urlError.userInfo["HTTPStatusCode"] as? Int,
                       (statusCode == 400 || statusCode == 401 || statusCode == 403 || statusCode == 500) {
                        DispatchQueue.main.async {
                            print("üîî Sending showAuthErrorAlert notification for HTTP \(statusCode) decoding error")
                            NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                                "title": "Phi√™n ƒêƒÉng Nh·∫≠p H·∫øt H·∫°n",
                                "message": "Phi√™n ƒëƒÉng nh·∫≠p c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá do l·ªói m√°y ch·ªß. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i."
                            ])
                        }
                        return Fail(error: NSError(domain: "", code: statusCode, userInfo: [NSLocalizedDescriptionKey: "Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá do l·ªói m√°y ch·ªß."])).eraseToAnyPublisher()
                    }
                    return Fail(error: error).eraseToAnyPublisher()
                }
                .flatMap { response in
                    Future<RefreshTokenResponse, Error> { promise in
                        if response.success && (200...299).contains(response.statusCode) {
                            UserDefaults.standard.set(response.data.token.accessToken, forKey: "authToken")
                            UserDefaults.standard.set(response.data.token.refreshToken, forKey: "refreshToken")
                            print("‚úÖ Successfully refreshed token")
                            promise(.success(response))
                        } else {
                            DispatchQueue.main.async {
                                print("üîî Sending showAuthErrorAlert notification for HTTP \(response.statusCode) error in refreshToken")
                                NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                                    "title": "Phi√™n ƒêƒÉng Nh·∫≠p H·∫øt H·∫°n",
                                    "message": "Phi√™n ƒëƒÉng nh·∫≠p c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i."
                                ])
                            }
                            promise(.failure(NSError(domain: "", code: response.statusCode, userInfo: [NSLocalizedDescriptionKey: "Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá: \(response.message)"])))
                        }
                    }
                }
                .eraseToAnyPublisher()
        }
    
    static func sendOTPRequest(to email: String, completion: @escaping (Bool, String?) -> Void) {
        guard let url = URL(string: "\(APIConfig.baseURL)/auth/email-send-otp") else {
            completion(false, "URL kh√¥ng h·ª£p l·ªá.")
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let body: [String: Any] = ["email": email]
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: body)
        } catch {
            completion(false, "L·ªói m√£ h√≥a d·ªØ li·ªáu: \(error.localizedDescription)")
            return
        }
        
        let config = URLSessionConfiguration.ephemeral
        config.timeoutIntervalForRequest = 20
        config.waitsForConnectivity = true
        
        let session = URLSession(configuration: config)
        session.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(false, "L·ªói k·∫øt n·ªëi: \(error.localizedDescription)")
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse, let data = data else {
                    completion(false, "Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ server.")
                    return
                }
                
                do {
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                        let success = json["success"] as? Bool ?? false
                        let message = json["message"] as? String ?? "Ph·∫£n h·ªìi kh√¥ng h·ª£p l·ªá t·ª´ server."
                        completion(success, success ? nil : message)
                    } else {
                        completion(false, "Ph·∫£n h·ªìi kh√¥ng h·ª£p l·ªá.")
                    }
                } catch {
                    completion(false, "L·ªói ph√¢n t√≠ch ph·∫£n h·ªìi: \(error.localizedDescription)")
                }
            }
        }.resume()
    }
    
    func verifyOTP(request: [String: String]) -> AnyPublisher<VerifyOTPResponse, Error> {
        guard let url = URL(string: "\(APIConfig.baseURL)/auth/email-verify-otp") else {
            return Fail(error: URLError(.badURL)).eraseToAnyPublisher()
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            urlRequest.httpBody = try JSONSerialization.data(withJSONObject: request)
        } catch {
            return Fail(error: error).eraseToAnyPublisher()
        }
        
        return networkManager.performRequest(urlRequest, decodeTo: VerifyOTPResponse.self)
    }

    func updateUserProfile(firstName: String?, lastName: String?, username: String?) -> AnyPublisher<UpdateProfileResponse, Error> {
        guard let token = UserDefaults.standard.string(forKey: "authToken") else {
            print("‚ùå Kh√¥ng t√¨m th·∫•y token x√°c th·ª±c trong UserDefaults")
            DispatchQueue.main.async {
                print("üîî Sending showAuthErrorAlert notification for missing auth token")
                NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                    "title": "Phi√™n ƒêƒÉng Nh·∫≠p Kh√¥ng H·ª£p L·ªá",
                    "message": "Phi√™n ƒëƒÉng nh·∫≠p c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i."
                ])
                AuthManager().logout()
            }
            return Fail(error: URLError(.userAuthenticationRequired)).eraseToAnyPublisher()
        }

        guard let url = URL(string: "\(APIConfig.baseURL)/users/me") else {
            print("‚ùå URL kh√¥ng h·ª£p l·ªá: \(APIConfig.baseURL)/users/me")
            return Fail(error: URLError(.badURL)).eraseToAnyPublisher()
        }

        var body: [String: Any] = [:]
        if let firstName = firstName { body["first_name"] = firstName }
        if let lastName = lastName { body["last_name"] = lastName }
        if let username = username { body["username"] = username }

        guard let requestBody = try? JSONSerialization.data(withJSONObject: body) else {
            print("‚ùå JSON Encoding Error")
            return Fail(error: URLError(.cannotParseResponse)).eraseToAnyPublisher()
        }

        print("üì§ Request body: \(String(data: requestBody, encoding: .utf8) ?? "Kh√¥ng th·ªÉ decode body")")
        let request = NetworkManager.createRequest(url: url, method: "PATCH", token: token, body: requestBody)

        return networkManager.performRequest(request, decodeTo: UpdateProfileResponse.self)
            .flatMap { response in
                Future<UpdateProfileResponse, Error> { promise in
                    if response.success && (200...299).contains(response.statusCode) {
                        print("‚úÖ C·∫≠p nh·∫≠t profile th√†nh c√¥ng")
                        promise(.success(response))
                    } else if response.statusCode == 400 {
                        print("‚ùå C·∫≠p nh·∫≠t profile th·∫•t b·∫°i: [\(response.statusCode)] \(response.message)")
                        promise(.failure(NSError(domain: "", code: 400, userInfo: [NSLocalizedDescriptionKey: "T√™n ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng, vui l√≤ng ch·ªçn t√™n kh√°c!"])))
                    } else {
                        print("‚ùå C·∫≠p nh·∫≠t profile th·∫•t b·∫°i: [\(response.statusCode)] \(response.message)")
                        promise(.failure(NSError(domain: "", code: response.statusCode, userInfo: [NSLocalizedDescriptionKey: response.message.isEmpty ? "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t h·ªì s∆°, vui l√≤ng th·ª≠ l·∫°i sau!" : response.message])))
                    }
                }
            }
            .catch { error -> AnyPublisher<UpdateProfileResponse, Error> in
                if (error as? URLError)?.code == .userAuthenticationRequired {
                    print("‚ùå Token kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n t·ª´ server")
                    DispatchQueue.main.async {
                        print("üîî Sending showAuthErrorAlert notification for userAuthenticationRequired")
                        NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                            "title": "Phi√™n ƒêƒÉng Nh·∫≠p Kh√¥ng H·ª£p L·ªá",
                            "message": "Phi√™n ƒëƒÉng nh·∫≠p h·∫øt h·∫°n, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!"
                        ])
                        AuthManager().logout()
                    }
                    return Fail(error: NSError(domain: "", code: URLError.userAuthenticationRequired.rawValue, userInfo: [NSLocalizedDescriptionKey: "Phi√™n ƒëƒÉng nh·∫≠p h·∫øt h·∫°n, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!"])).eraseToAnyPublisher()
                } else {
                    print("‚ùå L·ªói khi c·∫≠p nh·∫≠t profile: \(error.localizedDescription)")
                    DispatchQueue.main.async {
                        print("üîî Sending showAuthErrorAlert notification for profile update error")
                        NotificationCenter.default.post(name: .showAuthErrorAlert, object: nil, userInfo: [
                            "title": "L·ªói K·∫øt N·ªëi",
                            "message": "C√≥ l·ªói khi c·∫≠p nh·∫≠t h·ªì s∆°: \(error.localizedDescription)"
                        ])
                    }
                    return Fail(error: NSError(domain: "", code: (error as NSError).code, userInfo: [NSLocalizedDescriptionKey: "T√™n ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng, vui l√≤ng ch·ªçn t√™n kh√°c!"])).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }
}
